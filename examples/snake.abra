use term
use time

println("hello from snake")

// types

type Point = {
  x: int
  y: int
}

// TODO: need to make enums properly namespaced
type Direction = 
  | DirUp
  | DirDown
  | DirLeft
  | DirRight

type Snake = {
  body: array<Point>
  direction: Direction
}

// game logic

// TODO: this causes a crash
// let snake = Snake([Point(10, 10)], DirRight)

fn main() {
  let snake = Snake([Point(10, 10)], DirRight)
  let quit = false

  // game loop
  enable_raw_mode()
  while true {
    if poll_key_event() {
      match get_key_event() {
        Left -> { snake.direction <- DirLeft }
        Char("a") -> { snake.direction <- DirLeft }
        Right -> { snake.direction <- DirRight }
        Char("d") -> { snake.direction <- DirRight }
        Up -> { snake.direction <- DirUp }
        Char("w") -> { snake.direction <- DirUp }
        Down -> { snake.direction <- DirDown }
        Char("s") -> { snake.direction <- DirDown }
        Char("q") -> { quit <- true }
        Esc -> { quit <- true }
        _ -> {}      
      }
    }

    if quit {
      break
    }

    clear()

    display_snake(snake)

    // let body = snake.body
    // let segment: Point = body[0]

    update_snake(snake)
    
    flush()
  }

  // cleanup
  clear()
  disable_raw_mode()
  flush()
}

main()

// helper functions
fn display_snake(snake: Snake) {
  var i = 0
  while i < len(snake.body) {
    // TODO: this doesn't typecheck and/or parse
    //let x = snake.body[i].x
    //let y = snake.body[i].y
    let body: array<Point> = snake.body
    let segment: Point = body[i]
    let x = segment.x
    let y = segment.y

    mark("O", x, y)

    i <- i + 1
  }
}

fn update_snake(snake: Snake) {
  let body = snake.body
  let segment: Point = body[0]
  segment.x <- segment.x + 1
}

