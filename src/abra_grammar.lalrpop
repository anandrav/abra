use std::rc::Rc;
use std::str::FromStr;
use ast::*;

grammar;

Int: i32 = {
    r"[0-9]+" => i32::from_str(<>).unwrap()
}

Bool: bool = {
    "true" => true,
    "false" => false
}

Str: String = {
    r#""[^"]*""# => {
      let a = <>;
      a[1..a.len()-1].to_string()
    }
};

Unit: () = {
    "()" => ()
}

Identifier: Identifier = {
    r"[a-zA-Z_.][.a-zA-Z_0-9']*(\.:[.+/*=-]+)?" => (<>).to_string()
}

PatKind: Rc<PatKind> = {
    Identifier => Rc::new(PatKind::Var(<>))
}

Type: Rc<Type> = {
    <t_in:TypePrimitive> "->" <t_out:Type> => Rc::new(Type::Arrow(<>)),
    TypePrimitive
}

TypePrimitive: Rc<Type> = {
    "()" => Rc::new(Type::Unit),
    "int" => Rc::new(Type::Int),
    "bool" => Rc::new(Type::Bool),
    "string" => Rc::new(Type::String)
}

Rule: Rule = {
    "|" <pat:Pat> "->" <e:Expr> => (pat, e)
}

TypeAnn: Rc<Type> = {
    ":" <t:Type> => t
}

FuncArg: FuncArg = {
    <id:Identifier> <typ:TypeAnn?> => (id, typ)
}

CommaFuncArg: FuncArg = {
    "," <id:Identifier> <typ:TypeAnn?> => (id, typ)
}

TypeAnnFuncOut: Rc<Type> = {
    "->" <t:Type> => t
}

pub Stmt: Rc<Stmt> = {
    <lo:@L> <stmtkind:StmtKind> <hi:@R> => Rc::new(Stmt{stmtkind, span: Span{lo, hi}})
}

pub Expr: Rc<Expr> = {
    <lo:@L> <exprkind:ExprKind> <hi:@R> => Rc::new(Expr{exprkind, span: Span{lo, hi}}),
    EqualityOpExpr,
}

Pat: Rc<Pat> = {
    <lo:@L> <patkind:PatKind> <hi:@R> => Rc::new(Pat{patkind, span: Span{lo, hi}})
}

StmtKind: Rc<StmtKind> = {
    SemicolonOp => Rc::new(StmtKind::EmptyHole),
    <e:Expr> SemicolonOp => Rc::new(StmtKind::Expr(e)),
    "let" <pat:Pat> "=" <e:Expr> SemicolonOp => Rc::new(StmtKind::Let(pat, None, e)),
    "let" <pat:Pat> ":" <typ:Type> "=" <e:Expr> SemicolonOp => Rc::new(StmtKind::Let(pat, Some(typ), e)),
}

ExprKind: Rc<ExprKind> = {
    "func" "(" <func_arg:FuncArg> <func_args:CommaFuncArg*> ")" <t_out:TypeAnnFuncOut?> "{" <body:Expr> "}" => Rc::new(ExprKind::Func(func_arg, func_args, t_out, body)),
    "if" <e1:Expr> "{" <e2:Expr> "} else {" <e3:Expr> "}" => Rc::new(ExprKind::If(<>)),
    "match" <e1:Expr> "{" <rules:Rule*> "}" => Rc::new(ExprKind::Match(e1, rules)),
    "{" <statements:Stmt*> <final_operand:Expr?> "}" => Rc::new(ExprKind::Block(statements, final_operand)),
}

CommaExpr: Rc<Expr> = {
    "," <expr:Expr> => expr
}

EqualityOpExpr: Rc<Expr> = {
    <lo:@L> <e1:EqualityOpExpr> <op:EqualityOp> <e2:ComparisonOpExpr> <hi:@R> => Rc::new(Expr{exprkind: Rc::new(ExprKind::BinOp(e1, op, e2)), span: Span{lo, hi}}),
    ComparisonOpExpr
}

ComparisonOpExpr: Rc<Expr> = {
    <lo:@L> <e1:ComparisonOpExpr> <op:ComparisonOp> <e2:SummandOpExpr> <hi:@R> => Rc::new(Expr{exprkind: Rc::new(ExprKind::BinOp(e1, op, e2)), span: Span{lo, hi}}),
    SummandOpExpr
}

SummandOpExpr: Rc<Expr> = {
    <lo:@L> <e1:SummandOpExpr> <op:SummandOp> <e2:FactorOpExpr> <hi:@R> => Rc::new(Expr{exprkind: Rc::new(ExprKind::BinOp(e1, op, e2)), span: Span{lo, hi}}),
    FactorOpExpr
}

FactorOpExpr: Rc<Expr> = {
    <lo:@L> <e1:FactorOpExpr> <op:FactorOp> <e2:TermSpanned> <hi:@R> => Rc::new(Expr{exprkind: Rc::new(ExprKind::BinOp(e1, op, e2)), span: Span{lo, hi}}),
    FuncApExpr
}

FuncApExpr: Rc<Expr> = {
    <lo:@L> <f:FuncApExpr> "(" <e:Expr> <es:CommaExpr*> ")" <hi:@R> => Rc::new(Expr{exprkind: Rc::new(ExprKind::FuncAp(f, e, es)), span: Span{lo, hi}}),
    TermSpanned
}

TermSpanned: Rc<Expr> = {
    <lo:@L> <t:Term> <hi:@R> => Rc::new(Expr{exprkind: t, span: Span{lo, hi}}),
}

Term: Rc<ExprKind> = {
    Identifier => Rc::new(ExprKind::Var(<>)),
    Unit => Rc::new(ExprKind::Unit),
    Int => Rc::new(ExprKind::Int(<>)),
    Bool => Rc::new(ExprKind::Bool(<>)),
    Str => Rc::new(ExprKind::Str(<>)),
    "(" <ExprKind> ")",
}

FactorOp: BinOpcode = {
    "*" => BinOpcode::Multiply,
    "/" => BinOpcode::Divide
}

SummandOp: BinOpcode = {
    "+" => BinOpcode::Add,
    "-" => BinOpcode::Subtract,
}

EqualityOp: BinOpcode = "==" => BinOpcode::Equals;

ComparisonOp: BinOpcode = {
    "<" => BinOpcode::LessThan,
    "<=" => BinOpcode::LessThanOrEquals,
    ">" => BinOpcode::GreaterThan,
    ">=" => BinOpcode::GreaterThanOrEquals,
}

SemicolonOp: BinOpcode = ";" => BinOpcode::Semicolon;