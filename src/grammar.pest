WHITESPACE = _{ space | tab | newline }
space = { " " }
tab = { "\t" }
newline = { "\n" }

program = { SOI ~ statement* ~ EOI }

statement = _{ let_func_statement | let_statement | expression_statement }

let_statement = { let_keyword ~ pattern_annotated ~ op_assign ~ expression ~ semicolon }
let_keyword = _{ "let" }
expression_statement = { expression ~ semicolon }
pattern = _{ tuple_pat | wildcard | identifier }
wildcard = @{ "_" } // TODO this doesn't parse yet.
op_assign = _{ "=" }

let_func_statement = { let_keyword ~ identifier ~ func_args ~ func_out_annotation? ~ op_assign ~ expression ~ semicolon }

tuple_pat = { tuple_start ~ (tuple_pat_element ~ ",")+ ~ tuple_pat_element ~ tuple_end }
tuple_pat_element = _{ pattern }

expression = { term ~ (op_binary ~ term)* }
term = _{ block_expression | func_expression | func_call_expression | parenthesized_expression | if_else_expression | tuple_expr | primary_expression }

if_else_expression = { if_keyword ~ expression ~ expression ~ else_keyword ~ expression }
if_keyword = _{ "if" }
else_keyword = _{ "else" }

block_expression = { block_start ~ statement* ~ expression? ~ block_end }
block_start = _{ "{" }
block_end = _{ "}" }

tuple_expr = { tuple_start ~ (tuple_expr_element ~ ",")+ ~ tuple_expr_element ~ tuple_end }
tuple_start = _{ "(" }
tuple_end = _{ ")" }
tuple_expr_element = _{ expression }

parenthesized_expression = _{ paren_start ~ expression ~ paren_end }
paren_start = _{ "(" }
paren_end = _{ ")" }

func_call_expression = { primary_expression ~ func_call_args }
func_call_args = _{ func_call_args_start ~ (func_call_arg ~ ",")* ~ func_call_arg? ~ func_call_args_end }
func_call_args_start = _{ "(" }
func_call_args_end = _{ ")" }
func_call_arg = _{ expression }

func_expression = { func_keyword ~ func_args ~ func_out_annotation? ~ expression }
func_out_annotation = { "->" ~ typ }
func_args_start = _{ "(" }
func_args_end = _{ ")" }
func_args = _{ func_args_start ~ (pattern_annotated ~ ",")* ~ pattern_annotated? ~ func_args_end }
func_keyword = _{ "func" }

pattern_annotated = { pattern ~ type_annotation? } // TODO: this doesn't work for functions yet.

type_annotation = _{ ":" ~ typ }
typ = { type_term ~ (type_op_binary ~ type_term)* }
type_term = _{ tuple_type | type_literal }

tuple_type = { tuple_start ~ (tuple_type_element ~ ",")+ ~ tuple_type_element ~ tuple_end }
tuple_type_element = _{ typ }

type_literal = _{ type_literal_unit | type_literal_number | type_literal_bool | type_literal_string | type_poly }
type_poly = @{ !keyword ~ "'" ~ (alpha | "_") ~ (alphanumeric | "_")* } // 'a, 'b, 'c, etc.
type_literal_unit = @{ "void" }
type_literal_number = @{ "int" }
type_literal_bool = @{ "bool" }
type_literal_string = @{ "string" }

type_op_binary = _{ type_op_arrow }
type_op_arrow = { "->" }

primary_expression = _{ identifier | literal }

identifier = @{ !keyword ~ (alpha | "_") ~ (alphanumeric | "_")* }
alpha = _{ 'a'..'z' | 'A'..'Z' }
alphanumeric = _{ alpha | '0'..'9' }

literal = _{ literal_unit | literal_number | literal_bool | literal_string }
literal_unit = @{ "nothing" }
literal_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
literal_string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
literal_bool = @{ "true" | "false" }

op_binary = _{op_eq | op_gte | op_lte | op_gt | op_lt | op_addition | op_subtraction | op_multiplication | op_division }
op_eq = { "==" }
op_gt = { ">" }
op_lt = { "<" }
op_gte = { ">=" }
op_lte = { "<=" }
op_addition = { "+" }
op_subtraction = { "-" }
op_multiplication = { "*" }
op_division = { "/" }

// NOTE: When changing this code, make sure you don't have a subset of a word before
// another word. For example: { "type" | "typeof" } will never match "typeof"
keyword = @{
   else_keyword | "false" | "func" | if_keyword | let_keyword | "nothing" | "true"
}

semicolon = _{ ";" }