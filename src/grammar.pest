WHITESPACE = _{ space | tab | newline }
space = { " " }
tab = { "\t" }
newline = { "\n" }

placeholder = { "_" }

program = { SOI ~ statement* ~ EOI }

statement = _{ let_statement | expression_statement }

let_statement = { let_keyword ~ pattern ~ op_assign ~ expression ~ semicolon }
let_keyword = { "let" }
expression_statement = { expression ~ semicolon }
pattern = _{ identifier }
op_assign = { "=" }

expression = _{ term ~ (op_binary ~ term)* }
term = _{ block_expression | func_expression | func_call_expression | parenthesized_expression | if_else_expression | primary_expression }

if_else_expression = { if_keyword ~ expression ~ expression ~ else_keyword ~ expression }
if_keyword = _{ "if" }
else_keyword = _{ "else" }

block_expression = { block_start ~ statement* ~ expression? ~ block_end }
block_start = _{ "{" }
block_end = _{ "}" }

parenthesized_expression = _{ paren_start ~ expression ~ paren_end }
paren_start = _{ "(" }
paren_end = _{ ")" }

func_call_expression = { identifier ~ func_args }
func_args = _{ func_args_start ~ (func_arg ~ ",")* ~ func_arg? ~ func_args_end }
func_args_start = { "(" }
func_args_end = { ")" }
func_arg = _{ expression }

func_expression = { func_keyword ~ func_args ~ block_expression }
func_keyword = { "func" }

primary_expression = _{ identifier | literal | placeholder }

identifier = @{ !keyword ~ (alpha | "_") ~ (alphanumeric | "_")* }
alpha = _{ 'a'..'z' | 'A'..'Z' }
alphanumeric = _{ alpha | '0'..'9' }

literal = _{ literal_unit | literal_number | literal_bool | literal_string }
literal_unit = @{ "()" }
literal_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
literal_string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
literal_bool = @{ "true" | "false" }

op_binary = _{op_eq | op_gt | op_lt | op_addition | op_subtraction | op_multiplication }
op_eq = { "==" }
op_gt = { ">" }
op_lt = { "<" }
op_addition = { "+" }
op_subtraction = { "-" }
op_multiplication = { "*" }
op_division = { "/" }

// NOTE: When changing this code, make sure you don't have a subset of a word before
// another word. For example: { "type" | "typeof" } will never match "typeof"
keyword = @{
   else_keyword | "false" | "func" | if_keyword | let_keyword | "true"
}

semicolon = { ";" }