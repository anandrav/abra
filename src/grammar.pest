WHITESPACE = _{ space | tab | newline }
space = { " " }
tab = { "\t" }
newline = { "\n" }

toplevel = _{ SOI ~ toplevel_item* ~ EOI }

toplevel_item = _{ adt_declaration | typealias | statement }

typealias = { "type" ~ identifier ~ "=" ~ typ}

adt_declaration = { "type" ~ identifier ~ type_args? ~ "=" ~ variant ~ ("|" ~ variant)* }
type_args = { "<" ~ (type_poly ~ ",")* ~ type_poly? ~ ">" }
variant = { identifier ~ packed_data? }
packed_data = _{ "of" ~ typ }

statement = _{ let_func_statement | let_statement | expression_statement }

let_statement = { let_keyword ~ let_pattern_annotated ~ op_assign ~ expression }
let_keyword = _{ "let" }
expression_statement = { expression }
let_pattern = _{ let_pattern_tuple | wildcard | identifier }
wildcard = @{ "_" } // TODO this doesn't parse yet.
op_assign = _{ "=" }

let_func_statement = { let_keyword ~ identifier ~ func_args ~ func_out_annotation? ~ op_assign ~ expression }

let_pattern_tuple = { tuple_start ~ (let_pattern_tuple_element ~ ",")+ ~ let_pattern_tuple_element ~ tuple_end }
let_pattern_tuple_element = _{ let_pattern }

expression = { term ~ (op_binary ~ term)* }
term = _{ block_expression | func_expression | func_call_expression | parenthesized_expression | if_else_expression | match_expression | tuple_expr | primary_expression }

if_else_expression = { if_keyword ~ expression ~ expression ~ (else_keyword ~ expression)? }
if_keyword = _{ "if" }
else_keyword = _{ "else" }

match_expression = { "match" ~ expression ~ match_branch ~ (match_branch)* }
match_branch = { match_pattern ~ "->" ~ expression }

match_pattern = { literal | wildcard | match_pattern_tuple | match_pattern_variant | match_pattern_variable }
match_pattern_tuple = { tuple_start ~ (match_pattern_tuple_element ~ ",")+ ~ match_pattern_tuple_element ~ tuple_end }
match_pattern_tuple_element = _{ match_pattern }
match_pattern_variant = { identifier ~ match_pattern_variant_data? }
match_pattern_variant_data = _{ "of" ~ match_pattern }
match_pattern_variable = @{ "~" ~ (alpha | "_") ~ (alphanumeric | "_")* }

block_expression = { block_start ~ statement* ~ block_end }
block_start = _{ "{" }
block_end = _{ "}" }

tuple_expr = { tuple_start ~ (tuple_expr_element ~ ",")+ ~ tuple_expr_element ~ tuple_end }
tuple_start = _{ "(" }
tuple_end = _{ ")" }
tuple_expr_element = _{ expression }

parenthesized_expression = _{ paren_start ~ expression ~ paren_end }
paren_start = _{ "(" }
paren_end = _{ ")" }

func_call_expression = ${ primary_expression ~ func_call_args }
func_call_args = !{ func_call_args_start ~ (func_call_arg ~ ",")* ~ func_call_arg? ~ func_call_args_end }
func_call_args_start = _{ "(" }
func_call_args_end = _{ ")" }
func_call_arg = _{ expression }

func_expression = { func_keyword ~ func_args ~ func_out_annotation? ~ expression }
func_out_annotation = { "->" ~ typ }
func_args_start = _{ "(" }
func_args_end = _{ ")" }
func_args = _{ func_args_start ~ (let_pattern_annotated ~ ",")* ~ let_pattern_annotated? ~ func_args_end }
func_keyword = _{ "func" }

let_pattern_annotated = { let_pattern ~ type_annotation? } // TODO: this doesn't work for functions yet.

type_annotation = _{ ":" ~ typ }
typ = { type_term ~ (type_op_binary ~ type_term)* }
type_term = _{ tuple_type | type_literal }

tuple_type = { tuple_start ~ (tuple_type_element ~ ",")+ ~ tuple_type_element ~ tuple_end }
tuple_type_element = _{ typ }

type_literal = _{ type_literal_unit | type_literal_number | type_literal_bool | type_literal_string | type_poly | identifier }
type_poly = @{ "'" ~ (alpha | "_") ~ (alphanumeric | "_")* } // 'a, 'b, 'c, etc.
type_literal_unit = @{ "void" }
type_literal_number = @{ "int" }
type_literal_bool = @{ "bool" }
type_literal_string = @{ "string" }

type_op_binary = _{ type_op_arrow }
type_op_arrow = { "->" }

primary_expression = _{ literal | identifier }

identifier = @{ (alpha | "_") ~ (alphanumeric | "_")* }
alpha = _{ 'a'..'z' | 'A'..'Z' }
alphanumeric = _{ alpha | '0'..'9' }

literal = _{ literal_unit | literal_number | literal_bool | literal_string }
literal_unit = @{ "nothing" }
literal_number = @{ "0" | ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }
literal_string = @{ "\"" ~ (!"\"" ~ ANY)* ~ "\"" }
literal_bool = @{ "true" | "false" }

op_binary = _{op_eq | op_gte | op_lte | op_gt | op_lt | op_addition | op_subtraction | op_multiplication | op_division }
op_eq = { "=" }
op_gt = { ">" }
op_lt = { "<" }
op_gte = { ">=" }
op_lte = { "<=" }
op_addition = { "+" }
op_subtraction = { "-" }
op_multiplication = { "*" }
op_division = { "/" }

// NOTE: When changing this code, make sure you don't have a subset of a word before
// another word. For example: { "type" | "typeof" } will never match "typeof"
keyword = @{
   "bool" | "else" | "false" | "func" | "let" | "if" | "int" | "match" | "string" | "type" | "nothing" | "true" | "void"
}

semicolon = _{ ";" }