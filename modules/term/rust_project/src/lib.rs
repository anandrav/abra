// This is @generated by Abra build system

mod term;
pub mod ffi {
    pub mod term {
        use crate::term;
        use abra_core::foreign_bindings::*;
        #[allow(unused)]
        use abra_core::vm::AbraInt;
        use std::ffi::c_void;
        pub enum KeyCode {
            Left,
            Right,
            Up,
            Down,
            Char(String),
            Esc,
            Space,
            Other,
        }
        impl VmFfiType for KeyCode {
            unsafe fn from_vm_unsafe(vm: *mut c_void, vm_funcs: &AbraVmFunctions) -> Self {
                unsafe {
                    (vm_funcs.deconstruct_variant)(vm);
                    let tag = (vm_funcs.pop_int)(vm);
                    match tag {
                        0 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Left
                        }
                        1 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Right
                        }
                        2 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Up
                        }
                        3 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Down
                        }
                        4 => {
                            let value: String = <String>::from_vm_unsafe(vm, vm_funcs);
                            KeyCode::Char(value)
                        }
                        5 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Esc
                        }
                        6 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Space
                        }
                        7 => {
                            (vm_funcs.pop)(vm);
                            KeyCode::Other
                        }
                        _ => panic!("unexpected tag encountered: {tag}"),
                    }
                }
            }
            unsafe fn to_vm_unsafe(self, vm: *mut c_void, vm_funcs: &AbraVmFunctions) {
                unsafe {
                    match self {
                        KeyCode::Left => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 0);
                        }
                        KeyCode::Right => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 1);
                        }
                        KeyCode::Up => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 2);
                        }
                        KeyCode::Down => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 3);
                        }
                        KeyCode::Char(value) => {
                            value.to_vm_unsafe(vm, vm_funcs);
                            (vm_funcs.construct_variant)(vm, 4);
                        }
                        KeyCode::Esc => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 5);
                        }
                        KeyCode::Space => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 6);
                        }
                        KeyCode::Other => {
                            (vm_funcs.push_int)(vm, 0);
                            (vm_funcs.construct_variant)(vm, 7);
                        }
                    }
                }
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$enable_raw_mode")]
        pub unsafe extern "C" fn enable_raw_mode(
            _vm: *mut c_void,
            vm_funcs: *const AbraVmFunctions,
        ) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::enable_raw_mode();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$disable_raw_mode")]
        pub unsafe extern "C" fn disable_raw_mode(
            _vm: *mut c_void,
            vm_funcs: *const AbraVmFunctions,
        ) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::disable_raw_mode();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$poll_key_event")]
        pub unsafe extern "C" fn poll_key_event(
            _vm: *mut c_void,
            vm_funcs: *const AbraVmFunctions,
        ) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                let milliseconds = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                let ret: bool = term::poll_key_event(milliseconds);
                ret.to_vm_unsafe(_vm, _vm_funcs);
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$get_key_event")]
        pub unsafe extern "C" fn get_key_event(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                let ret: KeyCode = term::get_key_event();
                ret.to_vm_unsafe(_vm, _vm_funcs);
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$clear")]
        pub unsafe extern "C" fn clear(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::clear();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$hide_cursor")]
        pub unsafe extern "C" fn hide_cursor(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::hide_cursor();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$show_cursor")]
        pub unsafe extern "C" fn show_cursor(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::show_cursor();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$mark")]
        pub unsafe extern "C" fn mark(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                let y = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                let x = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                term::mark(s, x, y);
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$flush")]
        pub unsafe extern "C" fn flush(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                term::flush();
            }
        }
        /// # Safety
        /// `vm` must be non-null and valid.
        #[unsafe(export_name = "abra_ffi$term$get_size")]
        pub unsafe extern "C" fn get_size(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
            unsafe {
                let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                let ret: Option<(AbraInt, AbraInt)> = term::get_size();
                ret.to_vm_unsafe(_vm, _vm_funcs);
            }
        }
    }
}
