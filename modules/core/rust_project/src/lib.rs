// This is @generated by Abra build system

mod core;
pub mod ffi {
    pub mod core {
        #[allow(unused)]
        use crate::core;
        #[allow(unused)]
        use abra_core::foreign_bindings::*;
        #[allow(unused)]
        use abra_core::vm::AbraInt;
        #[allow(unused)]
        use std::ffi::c_void;
        pub mod strings {
            #[allow(unused)]
            use crate::core::strings;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_len")]
            pub unsafe extern "C" fn string_len(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: AbraInt = strings::string_len(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_chars")]
            pub unsafe extern "C" fn string_chars(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: Vec<String> = strings::string_chars(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_lines")]
            pub unsafe extern "C" fn string_lines(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: Vec<String> = strings::string_lines(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_slice")]
            pub unsafe extern "C" fn string_slice(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let end = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                    let begin = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: String = strings::string_slice(s, begin, end);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_is_alphabetic")]
            pub unsafe extern "C" fn string_is_alphabetic(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: bool = strings::string_is_alphabetic(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_is_alphanumeric")]
            pub unsafe extern "C" fn string_is_alphanumeric(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: bool = strings::string_is_alphanumeric(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_is_numeric")]
            pub unsafe extern "C" fn string_is_numeric(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: bool = strings::string_is_numeric(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_to_upper")]
            pub unsafe extern "C" fn string_to_upper(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: String = strings::string_to_upper(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_to_lower")]
            pub unsafe extern "C" fn string_to_lower(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: String = strings::string_to_lower(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_to_int")]
            pub unsafe extern "C" fn string_to_int(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: Option<AbraInt> = strings::string_to_int(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$strings$string_to_float")]
            pub unsafe extern "C" fn string_to_float(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: Option<f64> = strings::string_to_float(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
        }
        pub mod list {
            #[allow(unused)]
            use crate::core::list;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
        }
        pub mod fs {
            #[allow(unused)]
            use crate::core::fs;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fread")]
            pub unsafe extern "C" fn fread(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: Option<String> = fs::fread(path);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fwrite")]
            pub unsafe extern "C" fn fwrite(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let contents = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    fs::fwrite(path, contents);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fexists")]
            pub unsafe extern "C" fn fexists(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: bool = fs::fexists(path);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fremove")]
            pub unsafe extern "C" fn fremove(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    fs::fremove(path);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$frename")]
            pub unsafe extern "C" fn frename(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let new_path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let old_path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    fs::frename(old_path, new_path);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fcopy")]
            pub unsafe extern "C" fn fcopy(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let dest = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let src = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    fs::fcopy(src, dest);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$fs$fappend")]
            pub unsafe extern "C" fn fappend(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let contents = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let path = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    fs::fappend(path, contents);
                }
            }
        }
        pub mod time {
            #[allow(unused)]
            use crate::core::time;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$time$get_time")]
            pub unsafe extern "C" fn get_time(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let ret: f64 = time::get_time();
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$time$sleep")]
            pub unsafe extern "C" fn sleep(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let seconds = <f64>::from_vm_unsafe(_vm, _vm_funcs);
                    time::sleep(seconds);
                }
            }
        }
        pub mod exec {
            #[allow(unused)]
            use crate::core::exec;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$exec$command")]
            pub unsafe extern "C" fn command(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let s = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: AbraInt = exec::command(s);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
        }
        pub mod math {
            #[allow(unused)]
            use crate::core::math;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
        }
        pub mod random {
            #[allow(unused)]
            use crate::core::random;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$random$random_float")]
            pub unsafe extern "C" fn random_float(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let max = <f64>::from_vm_unsafe(_vm, _vm_funcs);
                    let min = <f64>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: f64 = random::random_float(min, max);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$random$random_int")]
            pub unsafe extern "C" fn random_int(
                _vm: *mut c_void,
                vm_funcs: *const AbraVmFunctions,
            ) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let max = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                    let min = <AbraInt>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: AbraInt = random::random_int(min, max);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
        }
        pub mod env {
            #[allow(unused)]
            use crate::core::env;
            #[allow(unused)]
            use abra_core::foreign_bindings::*;
            #[allow(unused)]
            use abra_core::vm::AbraInt;
            #[allow(unused)]
            use std::ffi::c_void;
            /// # Safety
            /// `vm` must be non-null and valid.
            #[unsafe(export_name = "abra_ffi$core$env$get_var")]
            pub unsafe extern "C" fn get_var(_vm: *mut c_void, vm_funcs: *const AbraVmFunctions) {
                unsafe {
                    let _vm_funcs: &AbraVmFunctions = &*vm_funcs;
                    let key = <String>::from_vm_unsafe(_vm, _vm_funcs);
                    let ret: String = env::get_var(key);
                    ret.to_vm_unsafe(_vm, _vm_funcs);
                }
            }
        }
    }
}
