type list<T> = empty | cons(T, list<T>)

/*
fn range(lo: int, hi: int) {
    if lo > hi
        .empty
    else
        .cons(lo, range(lo + 1, hi))
}
*/

/*
TODO
 this should be a member function.
 Unfortunately, name resolution doesn't seem to work when it's a member function
 due to declaration order and recursion or something
 */
fn list_from_array_helper(a: array<T>, index: int) -> list<T> {
    if index == a.len() {
        .empty
    } else {
        .cons(a[index], list_from_array_helper(a, index + 1))
    }
}

extend list<T> {
    fn from_array(a: array<T>) -> list<T> {
        list_from_array_helper(a, 0)
    }

    fn fold(self, f: (U, T) -> U, acc: U) -> U {
        match self {
            .empty -> acc
            .cons(head, tail) -> tail.fold(f, f(acc, head))
        }
    }

    fn map(self, f: T -> U) -> list<U> {
        match self {
            .empty -> list.empty // TODO: shouldn't need this qualifier
            .cons(head, tail) -> .cons(f(head), tail.map(f))
        }
    }

    fn for_each(self, f: T -> U) -> void {
        match self {
            .empty -> nil
            .cons (head, tail) -> {
                f(head)
                tail.for_each(f)
            }
        }
    }

    fn filter(self, f: T -> bool) -> list<T> {
        match self {
            .empty -> list.empty // TODO: shouldn't need this qualifier
            .cons (head, tail) ->
                if f(head) { .cons(head, tail.filter(f)) } else { tail.filter(f) }
        }
    }

    fn reverse(self) -> list<T> {
        self.fold((acc, head) -> list.cons(head, acc), .empty)
    }
}

implement ToString for list<T ToString> {
    fn str(self) -> string {
        "[ " .. self.str_helper() .. " ]"
    }
}

extend list<T ToString> {
    fn str_helper(self) -> string {
        match self {
            list.empty -> ""
            list.cons(x, .empty) -> ToString.str(x)
            list.cons(x, xs) -> ToString.str(x) .. ", " .. xs.str_helper()
        }
    }
}
