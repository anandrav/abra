use core/math

type map<K, V> = {
    buckets: array<int>

    // entries struct-of-arrays style
    entry_keys:     array<K>
    entry_values:   array<V>
    entry_hashes:   array<int>
    entry_nexts:    array<int>
    entry_occupied: array<bool>

    count: int
    free_list: int
}

extend map<K, V> {
    fn new() -> map<K, V> {
        map(
            [], // buckets
            [], // keys
            [], // values
            [], // hashes
            [], // nexts
            [], // occupied
            0,
            -1
        )
    }
}

extend map<K Hash Equal, V> {
    fn len(self) -> int {
        self.count
    }

    fn insert(self, key: K, value: V) -> void {
        if self.entry_keys.len() >= self.buckets.len() {
            self.resize()
        }

        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        // check for updates; walk the collision chain
        var i = self.buckets[bucket_idx]
        while i != -1 {
            if self.entry_hashes[i] == hash_code {
                if self.entry_keys[i] == key {
                    self.entry_values[i] = value
                    return nil
                }
            }
            i = self.entry_nexts[i]
        }

        // either reuse a slot or create a new one
        var target_idx = -1

        if self.free_list != -1 {
            // grab slot from free list
            target_idx = self.free_list
            self.free_list = self.entry_nexts[target_idx]

            self.entry_keys[target_idx] = key
            self.entry_values[target_idx] = value
            self.entry_hashes[target_idx] = hash_code
            self.entry_nexts[target_idx] = self.buckets[bucket_idx]
            self.entry_occupied[target_idx] = true
        } else {
            // create new slot
            target_idx = self.entry_keys.len()

            self.entry_keys.push(key)
            self.entry_values.push(value)
            self.entry_hashes.push(hash_code)
            self.entry_nexts.push(self.buckets[bucket_idx])
            self.entry_occupied.push(true)
        }

        // link to new slot from buckets array
        self.buckets[bucket_idx] = target_idx
        self.count = self.count + 1
    }

    fn get(self, key: K) -> option<V> {
        if self.buckets.len() == 0 return .none

        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        var i = self.buckets[bucket_idx]
        while i != -1 {
            if self.entry_hashes[i] == hash_code {
                 if self.entry_keys[i] == key {
                    return .some(self.entry_values[i])
                }
            }
            i = self.entry_nexts[i]
        }
        .none
    }

    fn remove(self, key: K) -> bool {
        if self.buckets.len() == 0 return false

        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        var prev = -1
        var curr = self.buckets[bucket_idx]

        while curr != -1 {
            if self.entry_hashes[curr] == hash_code {
                if self.entry_keys[curr] == key {
                    // unlink from bucket chain
                    if prev == -1 {
                        self.buckets[bucket_idx] = self.entry_nexts[curr]
                    } else {
                        self.entry_nexts[prev] = self.entry_nexts[curr]
                    }

                    // add to free list
                    // reuse the 'next' field to point to the next free item
                    self.entry_nexts[curr] = self.free_list
                    self.entry_occupied[curr] = false // mark as deleted
                    self.free_list = curr

                    self.count = self.count - 1
                    return true
                }
            }

            prev = curr
            curr = self.entry_nexts[curr]
        }
        false
    }

    fn resize(self) {
        let old_len = self.buckets.len()
        let new_size = if old_len == 0 { 4 } else { old_len * 2 }

        let new_buckets = array.filled(-1, new_size)
        self.buckets = new_buckets

        // rehash existing entries
        for i in self.entry_keys.len() {
            // only re-add occupied slots
            if self.entry_occupied[i] {
                let h = self.entry_hashes[i]
                let bucket_idx = h.abs() % new_size

                self.entry_nexts[i] = self.buckets[bucket_idx]
                self.buckets[bucket_idx] = i
            }
        }
    }
}