use core/math

type map<K, V> = {
    buckets: array<int>
    entries: array<map_entry<K, V>>
    count: int
    free_list: int
}

type map_entry<K, V> = {
    key: K
    value: V
    hash_code: int
    next: int
}

extend map<K, V> {
    fn new() -> map<K, V> {
        map([], [], 0, -1)
    }
}

extend map<K Hash Equal, V> {
    fn len(self) -> int {
        self.count
    }

    fn insert(self, key: K, value: V) -> void {
        if self.entries.len() >= self.buckets.len() {
            self.resize()
        }

        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        // check for updates; collision chain walk
        var i = self.buckets[bucket_idx]
        while i != -1 {
            let entry = self.entries[i]
            if (entry.hash_code == hash_code) and (entry.key == key) {
                // found existing key, update value
                entry.value = value
                return nil
            }
            i = entry.next
        }

        // get existing or create new entry
        var target_idx = -1

        if self.free_list != -1 {
            // reuse an entry
            target_idx = self.free_list
            let recycled_entry = self.entries[target_idx]
            self.free_list = recycled_entry.next // pop from free list

            recycled_entry.key = key
            recycled_entry.value = value
            recycled_entry.hash_code = hash_code
            recycled_entry.next = self.buckets[bucket_idx]
        } else {
            // create a new entry
            target_idx = self.entries.len()
            let new_entry = map_entry(
                key,
                value,
                hash_code,
                self.buckets[bucket_idx] // Point to current head of chain
            )
            self.entries.push(new_entry)
        }

        // update bucket head to point to new entry
        self.buckets[bucket_idx] = target_idx
        self.count = self.count + 1
    }

    fn get(self, key: K) -> option<V> {
        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        var i = self.buckets[bucket_idx]
        while i != -1 {
            let entry = self.entries[i]
            if (entry.hash_code == hash_code) and (entry.key == key) {
                return .some(entry.value)
            }
            i = entry.next
        }
        .none
    }

    fn remove(self, key: K) -> bool {
        let hash_code = Hash.hash(key)
        let bucket_idx = hash_code.abs() % self.buckets.len()

        var prev = -1
        var curr = self.buckets[bucket_idx]

        while curr != -1 {
            let entry = self.entries[curr]

            if (entry.hash_code == hash_code) and (entry.key == key) {
                // found it. unlink it
                if prev == -1 {
                    // it was the head
                    self.buckets[bucket_idx] = entry.next
                } else {
                    // it was in the middle/end
                    let prev_entry = self.entries[prev]
                    prev_entry.next = entry.next
                }

                // add to free list
                entry.next = self.free_list
                self.free_list = curr

                self.count = self.count - 1
                return true
            }

            prev = curr
            curr = entry.next
        }
        false
    }

    fn resize(self) {
        let old_len = self.buckets.len()

        let new_size = if old_len == 0 {
            4
        } else {
            old_len * 2
        }

        let new_buckets = array.filled(-1, new_size)
        self.buckets = new_buckets

        // rehash existing entries
        for i in self.entries.len() {
            let entry = self.entries[i]
            let bucket_idx = entry.hash_code.abs() % new_size
            entry.next = self.buckets[bucket_idx]
            self.buckets[bucket_idx] = i
        }
    }
}
